@page "/conversion"
@using Microsoft.Extensions.Logging;
@using PDFtoImage
@using System.IO;
@using System.Runtime.InteropServices;
@using System.Reflection;
@inject ILogger<Conversion> Logger
@inject IJSRuntime JS

<script>
	window.downloadFileFromStream = async (fileName, contentStreamReference) => {
		const arrayBuffer = await contentStreamReference.arrayBuffer();
		const blob = new Blob([arrayBuffer]);
		const url = URL.createObjectURL(blob);
		const anchorElement = document.createElement('a');
		anchorElement.href = url;
		anchorElement.download = fileName ?? '';
		anchorElement.click();
		anchorElement.remove();
		URL.revokeObjectURL(url);
	}
</script>

<PageTitle>Conversion</PageTitle>

<InputFile OnChange="@LoadFiles" single />

@if (isLoading)
{
	<p>Uploading...</p>
}

@code {
	private int currentCount = 0;
	private bool isLoading;
	const long maxAllowedSize = 100 * 1000 * 1000;

	private void IncrementCount()
	{
		currentCount++;
	}

	private async Task LoadFiles(InputFileChangeEventArgs e)
	{
		try
		{
			isLoading = true;

			using var fs = new MemoryStream();
			using var outfs = new MemoryStream();
			await e.File.OpenReadStream(maxAllowedSize).CopyToAsync(fs);
			fs.Position = 0;
			PDFtoImage.Conversion.SavePng(outfs, fs);
			outfs.Position = 0;

			using var streamRef = new DotNetStreamReference(stream: outfs);

			await JS.InvokeVoidAsync("downloadFileFromStream", "Test.png", streamRef);
		}
		catch (Exception ex)
		{
			Logger.LogError("File: {Name} Error: {Error}", e.File.Name, ex.Message);
		}
		finally
		{
			isLoading = false;
		}
	}
}
