@page "/"
@using ByteSizeLib;
@using Microsoft.Extensions.Logging;
@using PDFtoImage
@using System.IO;
@using System.Runtime.InteropServices;
@using System.Reflection;
@using System.ComponentModel.DataAnnotations;
@using PDFtoImage.WebConverter.Models;
@using SkiaSharp;
@using System.Threading;
@using Thinktecture.Blazor.WebShare;
@using Thinktecture.Blazor.WebShare.Models;
@inject ILogger<Index> Logger
@inject IJSRuntime JS
@inject NavigationManager NavigationManager;
@inject WebShareService WebShareService;

<PageTitle>Conversion</PageTitle>

<div class="mb-3">
	<div class="row">
		<div class="col-sm">
			<EditForm Model=@Model OnValidSubmit="@Submit" @onreset="Reset">
				<DataAnnotationsValidator />

				<div class="btn-group" role="group">
					<button type="submit" class="btn btn-primary" disabled="@(IsLoading || Model.File == null)">
						<span class="spinner-border spinner-border-sm" role="status" aria-hidden="true" hidden="@(!IsLoading)"></span> Convert
					</button>
					<input type="reset" class="btn btn-outline-secondary" value="Reset" disabled="@IsLoading" />
				</div>

				<div class="mt-3 mx-auto">
					<ValidationSummary class="validation-errors alert alert-warning" role="list" />
				</div>

				<div class="alert alert-danger mx-auto" role="alert" hidden="@(LastException == null)">
					@LastException?.Message
				</div>

				<div class="alert alert-info mx-auto" role="alert" hidden="@(Model.File == null || Model.Output != null)">
					@(Model.File != null ? $"{Model.File.Name} ({ByteSize.FromBytes(Model.File.Size).ToString()}, {Model.File.ContentType})" : null)
				</div>

				<div class="card mt-3 mb-3">
					<h5 class="card-header">Input</h5>
					<div class="card-body">
						<div class="form-group row mb-1">
							<label for="fileUpload" class="col-sm-3 col-form-label">File</label>
							<div class="col-sm">
								<div class="row">
									<InputFile OnChange="OnInputFileChange" id="fileUpload" single class="custom-file-input form-control-file" accept="application/pdf" aria-describedby="uploadHint" />
								</div>
								<div class="row">
									<small id="uploadHint" class="form-text text-muted">@($"Max. file size of {ByteSize.FromBytes(MaxAllowedSize).ToString()}.")</small>
								</div>
							</div>
						</div>

						<div class="form-group row mb-1">
							<label for="fileUploapPassword" class="col-sm-3 col-form-label">Password</label>
							<div class="col-sm">
								<InputText @bind-Value="Model.Password" type="password" autocomplete="current-password" id="fileUploapPassword" class="form-control form-control-sm" placeholder="if needed" />
							</div>
						</div>

						<div class="form-group row">
							<label for="page" class="col-sm-3 col-form-label">Page</label>
							<div class="col-sm">
								<InputNumber @bind-Value="Model.Page" id="page" class="form-control form-control-sm" min="0" max="@int.MaxValue" step="1" />
							</div>

							<div class="col-sm" />
							<div class="col-sm" />
						</div>
					</div>
				</div>

				<div class="card mb-3">
					<h5 class="card-header">Output</h5>
					<div class="card-body">
						<div class="form-group row">
							<label for="fileType" class="col-sm-3 col-form-label">Format</label>
							<div class="col-sm">
								<InputSelect @bind-Value="Model.Format" id="fileType" class="form-control form-control-sm">
									@foreach (var format in RenderRequest.FormatWhitelist)
									{
										<option value="@format">@format</option>
									}
								</InputSelect>
							</div>

							<label for="quality" class="col-sm-3 col-form-label">Quality</label>
							<div class="col-sm">
								<InputNumber @bind-Value="Model.Quality" id="quality" class="form-control form-control-sm" min="0" max="100" step="1" aria-describedby="qualityHint" />
								<small id="qualityHint" class="form-text text-muted">Relevant for Jpeg only</small>
							</div>
						</div>
					</div>
				</div>

				<div class="card mb-3">
					<h5 class="card-header">Sizing &amp; rotation</h5>
					<div class="card-body">
						<div class="form-group row mb-1">
							<label for="width" class="col-sm-3 col-form-label">Width</label>
							<div class="col-sm">
								<InputNumber @bind-Value="Model.Width" id="width" class="form-control form-control-sm" min="1" max="@int.MaxValue" step="1" />
							</div>

							<label for="height" class="col-sm-3 col-form-label">Height</label>
							<div class="col-sm">
								<InputNumber @bind-Value="Model.Height" id="height" class="form-control form-control-sm" min="1" max="@int.MaxValue" step="1" />
							</div>
						</div>

						<div class="form-group row mb-1">
							<label for="dpi" class="col-sm-3 col-form-label" max="@int.MaxValue" step="1">DPI</label>
							<div class="col-sm">
								<InputNumber @bind-Value="Model.Dpi" id="dpi" class="form-control form-control-sm" min="1" max="@int.MaxValue" step="1" aria-describedby="dpiHint" disabled="@(Model.Width != null || Model.Height != null)" />
								<small id="dpiHint" class="form-text text-muted">If width &amp; height unset</small>
							</div>

							<label for="rotation" class="col-sm-3 col-form-label">Rotation</label>
							<div class="col-sm">
								<InputSelect @bind-Value="Model.Rotation" id="rotation" class="form-control form-control-sm" aria-describedby="rotationHint">
									@foreach (var rotation in Enum.GetValues<PdfRotation>())
									{
										<option value="@rotation">@(RenderRequest.GetRotationLocalized(rotation))</option>
									}
								</InputSelect>
								<small id="rotationHint" class="form-text text-muted">Degrees are clockwise</small>
							</div>
						</div>

						<div class="form-group row">
							<div class="col-sm">
								<InputCheckbox @bind-Value="Model.WithAspectRatio" id="withAspectRatio" class="form-check-input" disabled="@((Model.Width == null && Model.Height == null) || (Model.Width != null && Model.Height != null))" />
								<label for="withAspectRatio">Keep aspect ratio</label>
							</div>
						</div>
					</div>
				</div>

				<div class="card mb-3">
					<h5 class="card-header">Render options</h5>
					<div class="card-body">
						<div class="form-group row mb-1">
							<div>
								<InputCheckbox @bind-Value="Model.WithAnnotations" id="withAnnotations" class="form-check-input" />
								<label for="withAnnotations">Annotations</label>
							</div>
						</div>

						<div class="form-group row mb-1">
							<div>
								<InputCheckbox @bind-Value="Model.WithFormFill" id="withFormFill" class="form-check-input" />
								<label for="withFormFill">Form fill</label>
							</div>
						</div>
					</div>
				</div>
			</EditForm>
		</div>

		<div class="col-sm">
			<div hidden="@(IsLoading || Model.Output == null || LastException != null)">
				<div class="btn-group" role="group">
					<button type="button" class="btn btn-success" @onclick="DownloadImage">
						<span class="oi oi-data-transfer-download" aria-hidden="true" /> Download
					</button>
					@if (IsWebShareSupported)
					{
						<button type="button" class="btn btn-outline-success" @onclick="ShareImage">
							<span class="oi oi-share-boxed" aria-hidden="true" /> Share
						</button>
					}
				</div>
				<div class="card mt-3">
					<div class="card-body">
						<img id="outputImage" class="card-img-bottom" alt="The converted PDF output." style="max-width: 100%; width: auto; height: auto" />
					</div>
				</div>
			</div>
		</div>
	</div>
</div>

@code {
	public RenderRequest Model { get; set; } = new();

	public bool IsWebShareSupported { get; private set; } = false;

	public bool IsLoading { get; private set; }

	public Exception? LastException { get; private set; }

	protected override async Task OnInitializedAsync()
	{
		Program.FilesHandled -= OnFilesHandled;
		Program.FilesHandled += OnFilesHandled;

		IsWebShareSupported = await WebShareService.IsSupportedAsync();
	}

	private async void OnFilesHandled(object? sender, Program.HandledFileArgs args)
	{
		if (args.File == null)
			return;

		Model.File = new DummyFile(
			await args.File.GetNameAsync(),
			await args.File.GetLastModifiedAsync(),
			(long)await args.File.GetSizeAsync(),
			await args.File.GetTypeAsync()
		);

		Logger.LogInformation($"Handle file {Model.File.Name}.");

		Model.Input = new MemoryStream();
		var arrayBuffer = await args.File.ArrayBufferAsync();
		await Model.Input.WriteAsync(arrayBuffer);

		await args.File.DisposeAsync();

		this.StateHasChanged();
	}

	private async Task OnInputFileChange(InputFileChangeEventArgs e)
	{
		Model.File = e.File;
		Model.Input?.Dispose();
		Model.Input = null;
		Model.Output?.Dispose();
		Model.Output = null;
		this.StateHasChanged();

		await JS.InvokeVoidAsync("resetImage", "outputImage");
	}

	private async Task SetImage()
	{
		if (Model.Output == null)
		{
			await JS.InvokeVoidAsync("resetImage", "outputImage");
			return;
		}

		Model.Output.Position = 0;
		using var fs = new MemoryStream();
		await Model.Output.CopyToAsync(fs);
		fs.Position = 0;

		using var streamRef = new DotNetStreamReference(fs);
		await JS.InvokeVoidAsync("setImage", "outputImage", streamRef);
	}

	private async Task Reset()
	{
		Model.Dispose();
		Model = new();
		LastException = null;
		await JS.InvokeVoidAsync("resetImage", "outputImage");
	}

	private const long MaxAllowedSize = 250 * 1000 * 1000;

	private async Task Submit()
	{
		Logger.LogInformation($"Converting {Model}.");

		try
		{
			IsLoading = true;
			LastException = null;

			Model.Output = new MemoryStream();

			if (Model.Input == null)
			{
				Model.Input = new MemoryStream();
				await Model.File!.OpenReadStream(MaxAllowedSize).CopyToAsync(Model.Input);
			}

			Model.Input.Position = 0;
			SKBitmap? bitmap = null;
			bool encodeSuccess = false;

			await Task.Run(() =>
			{
				bitmap = PDFtoImage.Conversion.ToImage(
					Model.Input,
					leaveOpen: true,
					password: !string.IsNullOrEmpty(Model.Password) ? Model.Password : null,
					page: Model.Page,
					dpi: Model.Dpi,
					width: Model.Width,
					height: Model.Height,
					withAnnotations: Model.WithAnnotations,
					withFormFill: Model.WithFormFill,
					withAspectRatio: Model.WithAspectRatio,
					rotation: Model.Rotation

				);
				encodeSuccess = bitmap!.Encode(Model.Output, Model.Format, Model.Quality);
			});

			if (!encodeSuccess)
			{
				Model.Output?.Dispose();
				Model.Output = null;
			}

			await SetImage();
		}
		catch (Exception ex)
		{
			Logger.LogError(ex, $"Failed to convert {Model}.");
			LastException = ex;
		}
		finally
		{
			IsLoading = false;
		}
	}

	private async Task DownloadImage()
	{
		if (Model.Output == null)
			return;

		try
		{
			Model.Output.Position = 0;
			using var fs = new MemoryStream();
			await Model.Output.CopyToAsync(fs);
			fs.Position = 0;

			using var streamRef = new DotNetStreamReference(fs);
			await JS.InvokeVoidAsync("downloadFileFromStream", RenderRequest.GetOutputFileName(Model), streamRef);
		}
		catch (Exception ex)
		{
			Logger.LogError(ex, $"Failed to download {Model}.");
		}
	}

	private async Task ShareImage()
	{
		if (Model.Output == null)
			return;

		try
		{
			Model.Output.Position = 0;
			using var fs = new MemoryStream();
			await Model.Output.CopyToAsync(fs);
			fs.Position = 0;

			using var streamRef = new DotNetStreamReference(fs);

			var file = await JS.InvokeAsync<IJSObjectReference>("createFileFromStream", RenderRequest.GetOutputFileName(Model), RenderRequest.GetMimeType(Model.Format), streamRef);
			var data = new WebShareDataModel
				{
					Files = new[] { file }
				};

			if (!await WebShareService.CanShareAsync(data))
			{
				Logger.LogWarning($"Cannot web share {Model}.");
				return;
			}

			await WebShareService.ShareAsync(data);
		}
		catch (Exception ex)
		{
			Logger.LogError(ex, $"Failed to web share {Model}.");
		}
	}

	[JSInvokable]
	public static void ReceiveWebShareTarget(string formData)
	{
		Console.WriteLine($".NET: {formData}");
	}
}

<script>
	navigator.serviceWorker.addEventListener("message", event => {
		console.log('Receive: ' + event.data);
		DotNet.invokeMethod('PDFtoImage.WebConverter', 'ReceiveWebShareTarget', event.data.toString());
	});

	navigator.serviceWorker.ready
		.then(registration => {
			if (registration.active) {
				registration.active.postMessage('receive-webshare');
			}
		});

	window.createFileFromStream = async (fileName, mimeType, contentStreamReference) => {
		const arrayBuffer = await contentStreamReference.arrayBuffer();
		const blob = new Blob([arrayBuffer], { type: mimeType });
		return new File([blob], fileName, { type: blob.type });
	}

	window.downloadFileFromStream = async (fileName, contentStreamReference) => {
		const arrayBuffer = await contentStreamReference.arrayBuffer();
		const blob = new Blob([arrayBuffer]);
		const url = URL.createObjectURL(blob);
		const anchorElement = document.createElement('a');
		anchorElement.href = url;
		anchorElement.download = fileName ?? '';
		anchorElement.click();
		anchorElement.remove();
		URL.revokeObjectURL(url);
	}

	window.setImage = async (imageElementId, imageStream) => {
		const arrayBuffer = await imageStream.arrayBuffer();
		const blob = new Blob([arrayBuffer]);
		const url = URL.createObjectURL(blob);
		const image = document.getElementById(imageElementId);
		image.onload = () => {
			URL.revokeObjectURL(url);
		}
		image.src = url;
	}

	window.resetImage = async (imageElementId) => {
		const image = document.getElementById(imageElementId);
		image.src = 'favicon.png';
	}
</script>