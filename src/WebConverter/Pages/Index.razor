@page "/"
@using ByteSizeLib;
@using Microsoft.Extensions.Logging;
@using PDFtoImage
@using System.IO;
@using System.Runtime.InteropServices;
@using System.Reflection;
@using System.ComponentModel.DataAnnotations;
@using PDFtoImage.WebConverter.Models;
@using SkiaSharp;
@using System.Threading;
@inject ILogger<Index> Logger
@inject IJSRuntime JS
@inject NavigationManager NavigationManager;

<PageTitle>Conversion</PageTitle>

<div class="mb-3">
	<div class="row">
		<div class="col-sm">
			<EditForm Model=@Model OnValidSubmit="@Submit" @onreset="Reset">
				<DataAnnotationsValidator />

				<div class="btn-group" role="group">
					<button type="submit" class="btn btn-primary" disabled="@(IsLoading || Model.File == null)">
						<span class="spinner-border spinner-border-sm" role="status" aria-hidden="true" hidden="@(!IsLoading)"></span> Convert
					</button>
					<input type="reset" class="btn btn-outline-secondary" value="Reset" disabled="@IsLoading" />
				</div>

				<div class="mt-3 mx-auto">
					<ValidationSummary class="validation-errors alert alert-warning" role="list" />
				</div>

				<div class="alert alert-danger mx-auto" role="alert" hidden="@(LastException == null)">
					@LastException?.Message
				</div>

				<div class="alert alert-info mx-auto" role="alert" hidden="@(Model.File == null || Model.Output != null)">
					@(Model.File != null ? $"{Model.File.Name} ({ByteSize.FromBytes(Model.File.Size).ToString()}, {Model.File.ContentType})" : null)
				</div>

				<div class="card mt-3 mb-3">
					<h5 class="card-header">Input</h5>
					<div class="card-body">
						<div class="form-group row mb-1">
							<label for="fileUpload" class="col-sm-3 col-form-label">File</label>
							<div class="col-sm">
								<div class="row">
									<InputFile OnChange="OnInputFileChange" id="fileUpload" single class="custom-file-input form-control-file" accept="application/pdf" aria-describedby="uploadHint" />
								</div>
								<div class="row">
									<small id="uploadHint" class="form-text text-muted">@($"Max. file size of {ByteSize.FromBytes(MaxAllowedSize).ToString()}.")</small>
								</div>
							</div>
						</div>

						<div class="form-group row mb-1">
							<label for="fileUploapPassword" class="col-sm-3 col-form-label">Password</label>
							<div class="col-sm">
								<InputText @bind-Value="Model.Password" type="password" id="fileUploapPassword" class="form-control form-control-sm" placeholder="if needed" />
							</div>
						</div>

						<div class="form-group row">
							<label for="page" class="col-sm-3 col-form-label">Page</label>
							<div class="col-sm">
								<InputNumber @bind-Value="Model.Page" id="page" class="form-control form-control-sm" min="0" max="@int.MaxValue" step="1" />
							</div>

							<div class="col-sm" />
							<div class="col-sm" />
						</div>
					</div>
				</div>

				<div class="card mb-3">
					<h5 class="card-header">Output</h5>
					<div class="card-body">
						<div class="form-group row">
							<label for="fileType" class="col-sm-3 col-form-label">Format</label>
							<div class="col-sm">
								<InputSelect @bind-Value="Model.Format" id="fileType" class="form-control form-control-sm">
									@foreach (var format in RenderRequest.FormatWhitelist)
									{
										<option value="@format">@format</option>
									}
								</InputSelect>
							</div>

							<label for="quality" class="col-sm-3 col-form-label">Quality</label>
							<div class="col-sm">
								<InputNumber @bind-Value="Model.Quality" id="quality" class="form-control form-control-sm" min="0" max="100" step="1" aria-describedby="qualityHint" />
								<small id="qualityHint" class="form-text text-muted">Relevant for Jpeg only</small>
							</div>
						</div>
					</div>
				</div>

				<div class="card mb-3">
					<h5 class="card-header">Sizing &amp; rotation</h5>
					<div class="card-body">
						<div class="form-group row mb-1">
							<label for="width" class="col-sm-3 col-form-label">Width</label>
							<div class="col-sm">
								<InputNumber @bind-Value="Model.Width" id="width" class="form-control form-control-sm" min="1" max="@int.MaxValue" step="1" />
							</div>

							<label for="height" class="col-sm-3 col-form-label">Height</label>
							<div class="col-sm">
								<InputNumber @bind-Value="Model.Height" id="height" class="form-control form-control-sm" min="1" max="@int.MaxValue" step="1" />
							</div>
						</div>

						<div class="form-group row mb-1">
							<label for="dpi" class="col-sm-3 col-form-label" max="@int.MaxValue" step="1">DPI</label>
							<div class="col-sm">
								<InputNumber @bind-Value="Model.Dpi" id="dpi" class="form-control form-control-sm" min="1" max="@int.MaxValue" step="1" aria-describedby="dpiHint" disabled="@(Model.Width != null || Model.Height != null)" />
								<small id="dpiHint" class="form-text text-muted">If width &amp; height unset</small>
							</div>

							<label for="rotation" class="col-sm-3 col-form-label">Rotation</label>
							<div class="col-sm">
								<InputSelect @bind-Value="Model.Rotation" id="rotation" class="form-control form-control-sm" aria-describedby="rotationHint">
									@foreach (var rotation in Enum.GetValues<PdfRotation>())
									{
										<option value="@rotation">@(RenderRequest.GetRotationLocalized(rotation))</option>
									}
								</InputSelect>
								<small id="rotationHint" class="form-text text-muted">Degrees are clockwise</small>
							</div>
						</div>

						<div class="form-group row">
							<div class="col-sm">
								<InputCheckbox @bind-Value="Model.WithAspectRatio" id="withAspectRatio" class="form-check-input" disabled="@((Model.Width == null && Model.Height == null) || (Model.Width != null && Model.Height != null))" />
								<label for="withAspectRatio">Keep aspect ratio</label>
							</div>
						</div>
					</div>
				</div>

				<div class="card mb-3">
					<h5 class="card-header">Render options</h5>
					<div class="card-body">
						<div class="form-group row mb-1">
							<div>
								<InputCheckbox @bind-Value="Model.WithAnnotations" id="withAnnotations" class="form-check-input" />
								<label for="withAnnotations">Annotations</label>
							</div>
						</div>

						<div class="form-group row mb-1">
							<div>
								<InputCheckbox @bind-Value="Model.WithFormFill" id="withFormFill" class="form-check-input" />
								<label for="withFormFill">Form fill</label>
							</div>
						</div>
					</div>
				</div>
			</EditForm>
		</div>

		<div class="col-sm">
			<div hidden="@(IsLoading || Model.Output == null || LastException != null)">
				<input type="button" class="btn btn-secondary" value="Download" @onclick="DownloadImage" />
				<div class="card mt-3">
					<div class="card-body">
						<img id="outputImage" class="card-img-bottom" alt="The converted PDF output." style="max-width: 100%; width: auto; height: auto" />
					</div>
				</div>
			</div>
		</div>
	</div>
</div>

@code {
	public RenderRequest Model { get; set; } = new();

	public bool IsLoading { get; private set; }

	public Exception? LastException { get; private set; }

	protected override void OnInitialized()
	{
		Program.FilesHandled -= OnFilesHandled;
		Program.FilesHandled += OnFilesHandled;
	}

	private async void OnFilesHandled(object? sender, Program.HandledFileArgs args)
	{
		if (args.File == null)
			return;

		Model.File = new DummyFile(
			await args.File.GetNameAsync(),
			await args.File.GetLastModifiedAsync(),
			(long)await args.File.GetSizeAsync(),
			await args.File.GetTypeAsync()
		);

		Logger.LogInformation($"Handle file {Model.File.Name}.");

		Model.Input = new MemoryStream();
		var arrayBuffer = await args.File.ArrayBufferAsync();
		await Model.Input.WriteAsync(arrayBuffer);

		await args.File.DisposeAsync();

		this.StateHasChanged();
	}

	private async Task OnInputFileChange(InputFileChangeEventArgs e)
	{
		Model.File = e.File;
		Model.Input?.Dispose();
		Model.Input = null;
		Model.Output?.Dispose();
		Model.Output = null;
		this.StateHasChanged();

		await JS.InvokeVoidAsync("resetImage", "outputImage");
	}

	private async Task SetImage()
	{
		if (Model.Output != null)
		{
			Model.Output.Position = 0;
			using var fs = new MemoryStream();
			await Model.Output.CopyToAsync(fs);
			fs.Position = 0;

			using var streamRef = new DotNetStreamReference(fs);
			await JS.InvokeVoidAsync("setImage", "outputImage", streamRef);
		}
		else
		{
			await JS.InvokeVoidAsync("resetImage", "outputImage");
		}
	}

	private async Task Reset()
	{
		Model.Dispose();
		Model = new();
		LastException = null;
		await JS.InvokeVoidAsync("resetImage", "outputImage");
	}

	private const long MaxAllowedSize = 250 * 1000 * 1000;

	private async Task Submit()
	{
		Logger.LogInformation($"Converting {Model}.");

		try
		{
			IsLoading = true;
			LastException = null;

			Model.Output = new MemoryStream();

			if (Model.Input == null)
			{
				Model.Input = new MemoryStream();
				await Model.File!.OpenReadStream(MaxAllowedSize).CopyToAsync(Model.Input);
			}

			Model.Input.Position = 0;
			SKBitmap? bitmap = null;
			bool encodeSuccess = false;

			await Task.Run(() =>
			{
				bitmap = PDFtoImage.Conversion.ToImage(
					Model.Input,
					leaveOpen: true,
					password: !string.IsNullOrEmpty(Model.Password) ? Model.Password : null,
					page: Model.Page,
					dpi: Model.Dpi,
					width: Model.Width,
					height: Model.Height,
					withAnnotations: Model.WithAnnotations,
					withFormFill: Model.WithFormFill,
					withAspectRatio: Model.WithAspectRatio,
					rotation: Model.Rotation

				);
				encodeSuccess = bitmap!.Encode(Model.Output, Model.Format, Model.Quality);
			});

			if (!encodeSuccess)
			{
				Model.Output?.Dispose();
				Model.Output = null;
			}

			await SetImage();
		}
		catch (Exception ex)
		{
			Logger.LogError(ex, $"Failed to convert {Model}.");
			LastException = ex;
		}
		finally
		{
			IsLoading = false;
		}
	}

	private async Task DownloadImage()
	{
		if (Model.Output == null)
			return;

		Model.Output.Position = 0;
		using var fs = new MemoryStream();
		await Model.Output.CopyToAsync(fs);
		fs.Position = 0;

		using var streamRef = new DotNetStreamReference(fs);
		await JS.InvokeVoidAsync("downloadFileFromStream", $"{Model.File!.Name}.{Model.Format.ToString().ToLowerInvariant()}", streamRef);
	}
}


<script>
	window.downloadFileFromStream = async (fileName, contentStreamReference) => {
		const arrayBuffer = await contentStreamReference.arrayBuffer();
		const blob = new Blob([arrayBuffer]);
		const url = URL.createObjectURL(blob);
		const anchorElement = document.createElement('a');
		anchorElement.href = url;
		anchorElement.download = fileName ?? '';
		anchorElement.click();
		anchorElement.remove();
		URL.revokeObjectURL(url);
	}

	window.setImage = async (imageElementId, imageStream) => {
		const arrayBuffer = await imageStream.arrayBuffer();
		const blob = new Blob([arrayBuffer]);
		const url = URL.createObjectURL(blob);
		const image = document.getElementById(imageElementId);
		image.onload = () => {
			URL.revokeObjectURL(url);
		}
		image.src = url;
	}

	window.resetImage = async (imageElementId) => {
		const image = document.getElementById(imageElementId);
		image.src = null;
	}
</script>